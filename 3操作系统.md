# 操作系统

对硬件进行管理与抽象，为应用提供服务并进行管理。

### 1.死锁

死锁条件

死锁预防

### 2.线程进程协程

### 3.线程通讯

线程如何同步

### 4.进程线程

​	进程：程序。进程是系统进行资源调度和分配的一个独立单位。

​	线程：进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。

​	一个进程可以有多个线程，多个线程也可以并发执行 

堆栈的关系



https://www.cnblogs.com/Lxk0825/p/9559070.html

### 5.多线程同步

### 6.进程通信

匿名管道：父子进程，数据单向流动

高级管道

命名管道：半双工，无亲缘

消息队列

信号量

信号

共享内存

套接字



### 7.锁

##### 7.1死锁产生

互斥

不可抢占

占有并等待

环形等待

7.2





互斥锁

条件锁

自旋锁

读写锁

递归锁



### 8.内存管理

#### 8.1虚拟内存

​	应用程序面向虚拟内存编写。在运行时只是用虚拟地址。CPU负责将虚拟地址翻译成物理地址，操作系统负责设置虚拟地址与物理地址之间的映射。

​	操作系统仅将应用实际使用的虚拟地址进行翻译，提高内存资源的利用率。

​	每个程序只能看到自己的虚拟地址空间。保证不同程序内存隔离。

​	每个程序虚拟地址空间是统一连续的，降低了编程的复杂性。

##### 8.1.1MMU

（1）内存管理单元，虚拟地址转换成物理地址。

（2）主要机制：分段，分页。

（3）分段：

​		MMU查询段表得到该段物理内存区域。

​			虚拟地址：段号+段内地址。

​			段表：段号+起始地址+本段长度。

​			物理地址：起始地址+段内地址。

​		但是容易出现外部碎片：段与段之间出现碎片空间。

（4）分页

​	将虚拟地址与物理地址空间划分为连续等长的虚拟页。页长固定且相等。

​	操作系统为每个应用构造页表（虚拟页到物理页映射）

​	虚拟地址：虚拟页号+页内偏移量。

（5）多级页表

​	单级页表，页表会过大。单级页表可认为是以虚拟页号作为索引的数组。该数组起始地址（数组基地址）位于寄存器中。翻译地址时需要根据索引去查找，那么页表需要在物理内存中连续，且必需



全部预留。不然索引毫无意义。

​	多级页表为树形结构（部分创建）。可根据需求动态生成节点。因此当使用较小内存时页表会更省空间。

​	虚拟页号会进一步划分为k个部分（虚拟页号k，对应i级页表下的索引）

​	页表基地址寄存器存储0级页表，根据0级虚拟页号作为偏移获得下一级页表的首地址。

​	页大小：4kb。低12位：页内偏移

​	页表大小不能超过一个页面。

##### 8.1.2TLB

可简化成存储键值对的hash表。虚拟页号->物理页号

转址旁路缓存。是MMU内部单元。

多级页表显著减少页表大小。但是会导致地址翻译时间增加。（进行多次物理内存访问）













9.高并发

10.







# ----Linux

## 1.软连接

## 2.指令

## 3.IO多路复用

select

poll

epoll





# ----理论

## 1.

并发：一个时间段中多个进程同时执行

并行：一个时间点上同时执行



并发，共享，虚拟，异步







## 2.





