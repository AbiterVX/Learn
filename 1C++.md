# ----C++

# ----基本语法

### 1. 多态

##### 静态多态

​	函数重载，模板

##### 动态多态

​	虚函数

##### 宏多态

​	编译时替换，泛型。

##### 重写重载隐藏

​	重载：类中声明同名函数。

​	隐藏：派生类屏蔽基类同名函数，与参数列表无关。

​	重写（覆盖）：派生类重定义函数，函数名，返回值，参数列表一致。

##### 重载函数名字改编

​	name mangling符号改编

​	主要为了函数重载

​	函数名和参数列表决定名字。

​	仅当形参是引用或指针时，const形参才对符号名有影响。

### 2. 访问权限

### 3. 虚函数

​	虚函数机制

​	虚表保存在哪：数据段

##### 	纯虚函数抽象基类

##### 	虚析构函数

​		基类指针只会执行基类虚函数，不会执行派生类虚函数。若为虚函数则执行派生类虚函数。

​		从静态声明处开始析构，直到基类。

##### 	基类指针调用虚函数的情况

​		域，默认直接为子类虚函数。

### 4. 引用与指针

##### 		引用

### 5. 深拷贝浅拷贝

拷贝与赋值

​	拷贝构造函数：

​		对象作为函数的参数，以值传递的方式传给函数。　

​		对象作为函数的返回值，以值的方式从函数返回

​		使用一个对象给另一个对象初始化

​	赋值：

​		已有的对象进行赋值



### 6. new与malloc

​	动态创建对象的初始化

malloc/free 和 new/delete



### 7.类

​	类内存布局

​	实例化

### 8.模板

### 9.智能指针

哪个线程安全

线程安全



##### shared_ptr 

​	初始化：make_shared<>()，new直接初始化。

​	引用计数： 构造，函数传参加一。

​						销毁（局部指针离开作用域），赋新值，减一。

​						销毁会调用析构函数，当引用数为0时，销毁数据。

​	出现异常：在离开作用域后自动销毁。而new，delete不会执行。

​	可使用自定义delete。

​	shared_ptr<int> p(&i,func)

​	不支持管理动态数组，除非定义删除器。

​	使用引用计数本身是安全且无锁的，但对象读写不是。读写操作不原子化。

##### weak_ptr，循环引用

​	使用shared_ptr初始，并不会改变shared_ptr引用计数，weak_ptr指向对象可能会被释放。

​	可被shared_ptr/weak_ptr赋值，共享对象。

​	lock,返回一个shared_ptr

​	解决两个shared_ptr循环引用（不改变引用计数）。

##### unique_ptr

​	指向唯一对象，销毁时指向对象也被销毁。

​	new直接初始化。

​	release放弃所有权

​	禁止拷贝构造与赋值操作。

​	可存储在容器中，通过move。

​	可管理动态数组。int[]

##### auto_ptr

​	不能在容器中保存auto_ptr，不能从函数返回auto_ptr

​	复制和赋值会改变资源所有权

​	在STL容器中无法使用auto_ptr,编译错误，容器中的元素必须支持可复制可赋值。

​	auto_ptr销毁对象，赋值：指针被销毁，指向对象被隐式销毁，离开作用域自动销毁，包括异常。

​												  拷贝值使原对象为空，移交所有权。

### 10. 构造函数

默认构造函数

​	合成构造函数

​	委托构造函数

含参数构造函数

​	拷贝构造函数

​	移动构造函数



### 11. const，static，define

##### static

​	保持变量内容的持久。运行时为唯一一次初始化。

​	类的静态成员函数是属于整个类而非类的对象。没有this指针，它仅能访问类的静态数据和静态成员函数。

##### 	const

​		顶层const：指针是常量。

```c++
const int* ptr;
```

​		底层const：(指针)所指对象为常量。

​							 引用的const为底层const

```c++
int *const ptr;
const int a;
const int &r;	
```



##### const 与define

#define为常数不带类型

#define在预处理阶段起作用，const在编译运行时起作用

define是简单的字符串替换没有类型检查，const有对应的数据类型。

define占用代码段空间，const占用数据段空间。

const可进行调试，define不可进行调试

define可进行重定义，const不能重定义

define可用来防止头文件重复引用



### 12. 内存模型

代码段，数据段，bss段，堆，栈。

内存溢出原因



子类实例内存模型

类内存布局

内存管理：堆，栈，自由存储区，静态存储区。



##### 内存格局：

​	全局数据区：全局变量，静态数据，常量。类全局变量。

​	代码区：类成员函数，非成员函数代码

​	栈区：运行函数分配的局部变量，函数参数，返回数据，返回地址。

​	堆区（自由存储区）：

​			

​	非静态成员变量。构造函数会实例化，为每个对象生成一份拷贝。分配到栈区或堆区。

​	类非静态成员函数包含一个指向类对象的指针参数。this。

​	new对象只是分配成员变量，普通成员函数未使用成员变量可正常工作(类似static)。

​	但new没有初始虚函数指针，因此没有new无法调用虚函数

​	成员函数是否内联都不占用对象存储空间。内敛是调用时赋值代码。

​	对象只包含自己的数据(包括虚函数指针，虚基类指针)。

![img](../assets/20170301171352579)

​	结构偏移：最后的大小必须为类中最大成员长度的倍数。

​						作为其他类型成员，按照最大成员长度对齐。

##### 10.1影响对象大小因素

​	成员变量

​	虚函数表指针 vftptr

​	虚基类表指针 _vbtptr

​	内存对齐

##### 10.2空类

sizeof(A)=1	用于标识该对象

```c++
class A{}
```

##### 10.3只有成员变量的类

sizeof(B)=4*3=12

```c++
class B{
	int a;
	int b;
	int c;
}
```

##### 10.4只有虚函数的类

sizeof(C)=4 虚表指针

```c++
class C{
	virtual void f();
	virtual void g();
	virtual void h();
}
```

![img](../assets/20190542-19448cec698840069f24334afa858213.png)

##### 10.5成员变量和虚函数

sizeof(D)=4+4	成员+虚表指针

```c++
class D{
	int m_nAge;
	virtual void f0();
	virtual void g0();
	virtual void h0();
}
```

![img](http://images.cnitblog.com/blog/78946/201301/20191007-da15a78a8e4d48469ae59f3528cfba7d.png)

##### 10.6单一继承

sizeof(E)=sizeof(D)+4=8+4=12

```C++
class E:public D{
    int m_nChildren;
    virtual void f0();
    virtual void g1();
    virtual void h0();
} 
```

![img](../assets/20195722-7b59876a02da4840be19807bb74ba374.png)

虚表重复的进行覆盖，不重复的添加。

##### 10.7多继承

sizeof(C)=sizeof(A)+sizeof(B)+4=(4+4)+(4+2+2)+4=20

```c++
class CParent1{
    int m_nParent1;
    virtual void f0();
    virtual void g0();
    virtual void h0();
}
class CParent2{
    short m_nParent2;
    virtual void f1();
    virtual void g1();
    virtual void h1();
}
class CChildren:public CParent1,public CParent2{
    int m_nChildren;
    virtual void f0();
    virtual void g1();
    virtual void f2();	//
    virtual void h0();
    virtual void h1();
    virtual void h2();	//
}
```

![img](../assets/20195528-bc778d9884b9443586e326619e2afc18.png)

##### 10.8深度为2的继承

sizeof(D)=sizeof(C)+4=20+4=24

```c++
class GrandChildren:public CChildren{
	int m_nGrandChildren;
    virtual void f0();
    virtual void h1();
    virtual void f2();
    virtual void f3();
}
```

![img](../assets/20202629-6c67cc62beec44299fcde9c24fc1bbd1.png)

##### 10.9重复继承

​	继承多个虚表指针。进行覆盖。但是根基类会被重复拷贝。

![img](../assets/20233722-923833f1aabd410a9d7eaa10539bc05b.png)

![img](../assets/27134649-f1af0fa22b534a5da0076f70746b3a57.png)

##### 10.10单一虚继承

sizeof(CChildren)=20

![img](../assets/27142533-002c68535a4a463da49c7f149ddbdcb7.png)

![img](../assets/27154246-54ba3f1cc4cb4af995cad6a1d1c409f4.png)

##### 10.11多虚继承

(1)virtual Cparent1,CParent2

sizeof(CChildren)=24

![img](../assets/27160655-89c81bec9ff44976bd18ca3bb155c3c7.png)

![img](../assets/27161739-e36a050cd15f45bfab9102e3798f869e.png)

(2)CParent1,virtual CParent2

sizeof(CChildren)=24

![img](../assets/27160708-662f2ad380224a9ca23aa22e6ce14339.png)

![img](../assets/27162255-80ac349691ed4d79bd85f080ea0b2374.png)

(3)virtual CParent1,virtual CParent2

sizeof(CChildren)=28

![img](../assets/27160722-f5a4b0bae44c4349a059c3896374fadf.png)

![img](../assets/27163043-eda211cc4bb64d1da3774b1ba397bebc.png)

##### 10.12菱形虚多继承

sizeof(CChildren)=36

![img](../assets/27163844-d4287a5050cf4b2b9c0c32a21338ff2f.png)

![img](../assets/27165612-e0b8e91bc6b645e6a765aa6df4c856b4.png)





### 13. 析构函数

1。显式调用的时候，析构函数相当于的一个普通的成员函数

2。编译器隐式调用析构函数，如分配了堆内存，显式调用析构的话引起重复释放堆内存的异常

3。把一个对象看作占用了部分栈内存，占用了部分堆内存（如果申请了的话），这样便于理解这个问题      

系统隐式调用析构函数的时候，会加入释放栈内存的动作（而堆内存则由用户手工的释放）      

用户显式调用析构函数的时候，只是单纯执行析构函数内的语句，不会释放栈内存，摧毁对象



虚析构函数

​	从显示的类型处开始析构，从子类到父类。


### 14. allocator

memory头文件

```c++
allocator<> a;					//为类型__分配内存
auto const ptr=a.allocate(n);	//分配一段原始的未构造的内存，保存n个类型为T的对象。
a.construct(ptr,args);			//ptr为T*指针，传递构造函数。
destory(ptr);					//执行ptr指向对象的析构函数。
a.deallocate(p,n);				//释放内存。
```



### 15. extern



static 限制了变量的作用域只在该文件里

extern可以被其他类所访问。作用范围是整个工程



### 16. C++11新特性

auto

lambda表达式

右值引用

三个智能指针



### 17.编译

动态链接

gcc

### 18.可调对象

函数

函数指针

lambda表达式

bind创建的对象

重载了函数调用符的类。函数对象。

### 19.#include 与 命名空间

​	#include：全部复制到目标位置。





### 20.union

21.虚函数表覆盖

https://www.cnblogs.com/hushpa/p/5707475.html

22.内存溢出原因

### 23.memcpy与memmove区别

memcpy二维

作用为拷贝一定长度的内容

内存重叠，memmove保证正确

### 24.strncpy

如何实现

为何不安全

strcpy：若目标字符串所指内存空间不够大，则会造成缓存溢出。在末尾加上\0

strncpy：将源字符串前n字符拷贝到目标。

​				若源字符串小于n，则会拷贝源字符串并将目标字符串剩下部分全部置\0

​				目标字符串 长度大于n，目标字符串不会拷贝结尾\0

### 25.右值引用 && 

等号右边的值

解决的问题：当参数为右值时，解决了不必要的深拷贝



https://www.zhihu.com/question/22111546

### 26.类型转换函数

##### 	

##### 	static_cast

​		编译器认可的隐式类型转换

​		static_cast<>()

##### 	dynamic_cast

​		派生类指针或引用，与基类指针或引用转换。

​		运行时处理，运行时要进行运行时类型检查，其他三个是编译时完成。

​		基类中要有虚函数，因为运行时类型检查的类型信息在虚函数表中，有虚函数才会有虚函数表；

​		可以实现向上转型和向下转型，前提是必须使用public或protected继承；

##### 	const_cast

​		只改变运算对象的底层const。

​		去掉const

##### 	reinterpret_cast

​		重新解释的类型转换

​		对任意两个类型之间的变量相互转换，无视类型信息。

### 27.默认参数为什么放到最后

​	形参的压栈先后顺序，由后向前。

### 28.纯虚函数抽象基类

### 29.lambda

值捕获

引用捕获

### 30.友元

其他类/函数可访问非公有成员

不存在传递性，每个类负责控制自己的友元类/函数。

### 31.std:move 与std:forward

##### 	std:move

​		将左值引用转为右值引用

##### 	std:forward

​		接受一个右值引用的参数

​		将所有的参数类型原封不动的传递给目标函数



### 32.可变长参数

标准库	initialiazer_list:实参数量未知，但类型相同。

```
	initializer_list<String> SS
	包含begin end函数。
```

省略符：  参数列表最后位置添加： ...



可变参数模板：实现任意长度、任意类型参数

变长参数模板的典型使用方法：利用模板推导机制，每次从参数包里面取第一个元素，缩短参数包，直到包为空。

```c++
template<typename T, typename... Targs>
void tprintf(const char* format, T value, Targs... Fargs) {
   // recursive variadic function
   for (; *format != '\0'; format++) {
       if ( *format == '%' ) {
          std::cout << value;
           tprintf(format+1, Fargs...); // recursive call
           return;
        }
        std::cout << *format;
    }
}
```

### 33.C++函数调用约定

https://blog.csdn.net/weixin_39731083/article/details/82533349

### 34栈和堆

栈里除了局部变量还会存什么

函数调用的过程

1. 内存分哪五大区

装箱拆箱

map和unordered_map

# ----STL

## 1.vector

与数组区别

如何动态分配内存

size与capacity区别

与list区别

clear函数细节

push_back



##### push_back时间复杂度

​	m/m-1 常量时间。

##### 与list区别

​	vector动态数组，内存连续。高效的进行随机存取，时间复杂度为O(1)。

​	list双向链表，内存空间不连续，存取时间O(n)，高效的进行插入删除。

## 2.list



## 3.map set

与unorder_map区别

插入删除复杂度

底层实现



map与set不包含重复的数据。map含key与value。

set，map：红黑树（有序）

unordered_map：hash加链表，空间换时间。

## 4.哈希

冲突解决

## 5.STL迭代器失效

容器插入删除可能会导致迭代器失效。

vector

​	插入一个元素后，end操作方位的迭代器失效。

​	插入一个元素后，capacity返回值发生变化，first和end操作返回的迭代器都会失效。

​	进行删除操作后，指向删除点的迭代器将失效，指向删除点后面的元素的迭代器也将失效。

deque

​	在容器首部和尾部插入元素不会使迭代器失效。

​	在首部或尾部删除元素会使指向被删除元素的迭代器失效。

​	在容器的任何位置插入或删除操作将会使指向该容器元素的所有迭代器失效。

list/set/multiset/map/multimap

​	删除元素时，指向该元素的迭代器失效。

## 6.STL线程安全

## 7.strcpy

为什么线程不安全

将一个字符串拷贝到另一个字符串。如果超过长度。会写到其他地方。缓存区溢出。

strcpy_s指定了长度。







# ----多线程





# ----编译

### 1. h与cpp文件

​	h文件不对外隐藏，cpp文件编译后对外隐藏。

### 2.编译，链接

​	动态链接

##### 21.1预编译

​	.cpp文件生成 .i文件

​	(1)展开宏：#define 全部替换。

​	(2)处理预编译指令：#if #ifndef  #else  #endif 

​									（条件编译可执行条件选择，从而保证头文件只include一次）

​	(3)删除所有注释：/**/  //

​	(4)添加行号和文件名标识：便于编译时编译器产生调试行号信息和错误提醒。

​	(5)保留所有#pragma

​	(6)#include 替换为对应文件内容。

​		#include存放声明，因此放在cpp文件开始部分。

​		搜索头文件顺序

​			#include<> :从系统目录下开始搜索，然后搜索PATH环境变量所列出的目录，不搜索当前目录。

​			#include""  :从当前目录搜索，c++安装目录，然后系统目录和PATH环境变量所列出的目录

​			如果知道头文件在系统目录或PATH目录下，可通过<>加快搜索速度。

##### 21.2编译

​	.i文件生成.s文件，生成汇编代码。

​	词法分析，语法分析，语义分析，代码优化，代码生成。

##### 21.3汇编

​	.s生成.obj文件。机器码文件。

​	未解决符号表：提供所有在该编译单元里引用但定义并不在本编译单元里的符号及其出现的地址。 

​	导出符号表：提供了本编译单元具有定义，并且愿意提供给其他编译单元使用的符号及其地址。 

​	地址重定向表：提供了本编译单元所有对自身地址的引用的记录。	

##### 21.4链接

​	链接.obj文件，产生可执行文件	

​	决定各个.obj文件在最终exe文件的位置

​	访问地址重定向表，进行地址重定向。加上偏移量。

​	遍历所有目标文件的未解决符号表，在导出符号表查找符号。

​	在未解决符号表中所记录的位置填写实现地址。





##### 静态链接

​	在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件。

​	方便程序移植，在任何环境都可执行。

##### 动态链接

​	编译后只将声明部分编译到程序中，运行时需要dll（实现部分）文件支持。

​	优点：

​    （1）多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝。

​    （2）动态的加载需要的资源和函数，而不是一开始就加载，不需要一开始就为这些资源开辟内存空间，节省内存，提升效率。





