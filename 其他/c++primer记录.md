

C#中间语言，CIL

C#虚拟机CLR













## C++内存模型

线程同步。内存操作在其他线程的可见性。





# OOP

数据抽象，继承，多态。

### 1.派生类

派生列表

```c++
class A: public B
```

派生类向基类隐式转换。

### 2.动态绑定(运行时绑定)

函数运行版本由实参控制，运行时选择函数的版本。

当使用基类引用(指针)调用虚函数时将发生动态绑定。

### 3.虚函数

基类通常定义虚析构函数。

virtual 只出现在类内部声明，不能用于类外函数定义。

### 4.受保护的访问运算符

派生类能访问公有成员，不能访问私有成员。

protected：派生类有权访问，禁止其他用户访问。

### 5.派生类构造函数

```c++
A(int a,double b,float c): B(a,b),C(c)
```

构造初始化，初始基类构造函数。否则会默认初始化基类部分。

### 6.派生类使用基类成员

派生类可访问基类的公有成员和保护成员。

静态成员：只存在唯一实例。

### 7.派生类声明

不包含派生列表

被用作基类的类必须已经定义。

### 8.防止继承

final,禁止其他类继承该类。

```c++
class A final{}
```



### 9.基类与派生类转换

```c++
A a；
B* b=&a;
A* aa=b;  //错误
```

基类不能转换为派生类，即使基类指针绑定在派生类对象上。

编译器只能通过检查类型来判断是否合法。

### 10.赋值或拷贝

```c++
A a;
B b(a);  //剪切
b=a;     //剪切
```

当使用派生类对象为基类对象初始化或赋值时，只有派生类对象中的积累部分会被拷贝/赋值/移动，派生类部分将被忽略掉。

派生类向基类转换只对引用/指针类型有效。

基类向派生类不存在隐式转换。

转换可能由于访问受限变得不可行。

### 11.虚函数

虚函数需要定义。

基类中定义的虚函数在派生类中也为虚函数。

且虚函数类型参数完全一致。若返回类型为基类指针/引用类型，则派生类中返回值可为派生类指针/引用类型。

### 12.override

显示覆盖虚函数。在函数末尾添加override

### 13.final

函数末尾添加final，之后要覆盖此函数的操作都会错误。

### 14.虚函数默认实参

通过指针/引用调用虚函数，使用基类定义的默认实参。

### 15.回避虚函数机制

作用域运算符调用指定虚函数。在编译时完成解析。

### 16.纯虚函数

虚函数后加“ =0 ”，只能出现在类内部声明处。

































































